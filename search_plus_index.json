{"./":{"url":"./","title":"介绍","keywords":"","body":"AntDen是一个调度平台，可以方便的管理资源和重定义调度算法。它由下面几个组件组成 执行器： 负责任务的启动、停止、状态查看等。默认有两个执行器 exec用于执行命令，docker用于调用docker容器 客户端： 每个要被接入集群的机器都需要安装运行客户端。客户端负责调用执行器 控制器： 控制器负责和客户端的通信 调度器： 负责调度控制 看板： 控制台看板和API 命令行： 通过命令行提交查看任务 只需要简单的几步就可以部署AntDen服务，试试吧！！！快速开始 点击进入AntDen线上环境 AntDen 做了什么？ 他现实了一个调度平台，从任务的提交到调度到最后的任务执行。 但是把三个模块抽象出来方便用户很方便的重新定义。 调度算法， antden中可以方便的重新定义和替换你调度算法。 每个调度算法是一个可以单独执行的二进制，通过标准输入和输出通过Json进行数据交互。 同时antden中提供了模拟器来对用户编写的调度算法进行打分。 怎么添加调度算法 执行器, antden 负责调度配置的抽象，把用户提交的左右的配置最终调度到服务器上后， 需要一个指定的执行器进行解析并且执行，antden中默认放置了exec和docker的执行器， 分别用户执行服务器命令和运行docker。 定一个执行器需要5个插件，告诉antden改任务是怎么 启动，停止，状态查看，任务退出状态回收，任务配置格式检查。 怎么添加执行器 数据集管理： antden中内置了一个默认的数据集，是由rsyncd提供的服务。但是提供了一个很简易的 方式接入其他数据集管理平台。 数据集类型 （除此之外，antden只提供最原始的html格式的控制台，用户需要自己定义对接优美的前端。 同时antden的系统状态，资源使用情况，任务资源使用情况，通过json日志格式进行了输出， 默认使用elk进行了对接。） Demo Copyright 2020 - 2020. all right reserved，powered by Gitbook该文件修订时间： 2020-07-30 15:57:39 "},"quick_start/centos7.html":{"url":"quick_start/centos7.html","title":"极速安装(centos7)","keywords":"","body":"极速安装(系统：centos 7) 一键安装 curl -L get.antden.cn|sudo bash #只启动antden服务 curl -L get.antden.cn|elk=1 sudo bash #启动antden和elk 安装路径为当前路径下的AntDen 通过页面访问服务 http://ip:3000 默认管理员用户： 用户名 antden 密码 changeme 添加机器到集群中 根据settings中的步骤配置本地客户端 使用客户端 访问elk服务 http://ip:5601 默认用户： 用户名 antden 密码 changeme 在Management/Kibana/Index patterns 中添加 index: antden-* 在Management/Kibana/Saved Objects 中导入 AntDen/docker/docker-elk/antden-dashboard.ndjson 看板 Copyright 2020 - 2020. all right reserved，powered by Gitbook该文件修订时间： 2020-07-26 20:17:47 "},"quick_start/":{"url":"quick_start/","title":"快速开始(通用)","keywords":"","body":"快速安装 安装前提 安装了docker docker版本不能太低 下载AntDen代码 git clone https://github.com/data-o/AntDen 服务是在容器中运行的，下载代码时使用的用户最好是和容器服务是同一个用户，否则可能会出现文件权限的问题。 启动服务 cd AntDen ./control srv up -d 服务启动过程需要下载镜像和依赖，根据不同的网络情况，可能需要几分钟的时间。 通过页面访问服务 http://ip:3000 默认管理员用户： 用户名 antden 密码 changeme 添加机器到集群中 根据settings中的步骤配置本地客户端 使用客户端 启动elk服务(可选) cd AntDen ./control elk up -d http://ip:5601 默认用户： 用户名 antden 密码 changeme 在Management/Kibana/Index patterns 中添加 index: antden-* 在Management/Kibana/Saved Objects 中导入 AntDen/docker/docker-elk/antden-dashboard.ndjson 看板 Copyright 2020 - 2020. all right reserved，powered by Gitbook该文件修订时间： 2020-07-26 21:57:28 "},"quick_start/SSO.html":{"url":"quick_start/SSO.html","title":"登录接入(可选)","keywords":"","body":"登录接入（可选） 为什么要登录接入 AntDen默认会开启自己的用户登录功能，但是在生产环境中，公司内部会有单点登录系统（SSO）。 对接SSO后可以用统一的登录来进入AntDen。 对接步骤 重写 AntDen/dashboard/sso 和 AntDen/dashboard/ssoconfig 两个插件。 重写的插件可以不要覆盖默认的插件，可以放到新路径： AntDen/dashboard/private/code/sso 和 AntDen/dashboard/private/code/ssoconfig 。 系统判断有私有插件会首选使用私有插件。 ssoconfig 插件 #!# perl: code/ssoconfig use strict; use warnings; return sub { return +{ ssocallback => 'http://sso.antden.cn/login?callback=', cookiekey => 'u', ssologout => 'http://sso.antden.cn/logout', chpasswd => 'http://sso.antden.cn/chpasswd', } }; chpasswd 为修改密码的连接，可以为空，为空时用户在antden上点击修改密码会提示不支持 ssologout 为登出的连接,未定义情况下默认是清理key为cookiekey的cookie ssocallback(必要) 访问antden判断到用户没有登录时跳转的地址，antdne当前访问的地址会带在callback之后 登录成功后sso系统需要跳转回来 cookiekey(必要) SSO系统使用的cookie的名称，这个cookie的值会给另一个插件进行验证 sso 插件 #!# perl: code/sso use strict; use warnings; return sub { my $cookie = shift @_; # #通过$cookie 这个值去sso系统查询这个cookie的用户身份，获取用户的唯一标识， #如邮箱地址，用户名 （不要使用中文） # #如 获取到邮箱地址 $email # return $email; }; 例： 对接（聚云立方：https://console.marshotspot.com/） #!# perl: code/ssoconfig use strict; use warnings; return sub { return +{ ssocallback => 'https://console.marshotspot.com/account/login?redirect=', cookiekey => 'token', } }; #!# perl: code/sso use strict; use warnings; use Mojo::JWT; return sub { my $claims = eval{ Mojo::JWT->new(secret => 'sercet123456' )->decode(shift); }; return $@ ? undef : $claims->{email}; }; }; Copyright 2020 - 2020. all right reserved，powered by Gitbook该文件修订时间： 2020-07-26 20:00:02 "},"quick_start/framework.html":{"url":"quick_start/framework.html","title":"架构图","keywords":"","body":"架构图 总架构 客户端 控制器 调度器 Copyright 2020 - 2020. all right reserved，powered by Gitbook该文件修订时间： 2020-07-26 21:50:42 "},"quick_start/executer.html":{"url":"quick_start/executer.html","title":"执行器","keywords":"","body":"执行器 看例子 这个是dashboard上默认的提交任务的例子。下面看一下任务怎么和执行器相关联的。 可以看到，一个作业的提交包含5个信息 提交者： 在dashboard和antdencli中提交，系统会记录提交者的名称，默认情况下只有提交者可以看到自己提交的作业 Nice, 优先级从0-9，默认是5，数字约低越先调度 group 作业提交到的资源组 Name 作业名，用于标记 作业的yaml文件 作业的yaml文件 可以看到作业的yaml文件包含两个重要的字段， executer 和 scheduler. 其中scheduler 是提供给调取算法的配置，executer 是执行器的配置。 这个配置传入调取模块后，调度模块会把一个JOB生成一个或者多个的task。每一个task最终会找到 一个机器上的某个执行器去执行。配置会有响应的转换。 如上图的配置转换成执行器后变成如下 resources: [ 'CPU', 0, 2 ] param: exec: sleep 300 taskid: T.20191120.191012.907980.111.001 原配置中的executer.param 会被原封不动的保留提供给执行器。 resources 为该任务可以使用到的资源。执行器应该按照这个资源表给任务分配资源。 taskid为此任务的编号。 执行器的5个插件 执行器的插件位置存放在 /opt/AntDen/slave/code/executer 下，改目录下每一个执行器是一个目录， 可以看到里面有两个目录，exec和docker，下面看一下exec目录下的5个插件文件 checkparams （ 检查作业的yaml格式） #!# perl: code/ use warnings; use strict; =head3 param exec: sleep 100 =cut return sub { my $param = shift @_; die \"exec undef\" unless $param->{exec}; return; }; 这个插件是用来检查提交进来的作业的配置格式是否正确，配置中执行器的名称是必须指定的， 但是每个执行器需要什么其他的数据，执行器定义的时候自己进行格式检查 start （启动任务） exec 的start执行器就是把exec的命令启动起来，同时返回改命令的进程ID status （任务状态） #!# perl: code/ use warnings; use strict; =head3 param param: executeid =head3 return return status, running or stoped =cut return sub { my $param = shift @_; return kill( 0, $param->{executeid} ) ? 'running' : 'stoped'; }; 在运行中的任务，机器上的slave程序会定时的检查每个task的状态。当状态是stoped时，进行日任务退出的后续操作 result (结果查看) 查看任务执行的最终结果， exec插件的result返回的是任务进程的返回码 sotp （停止任务） 停止任务的操作可能来之用户手动从dashboard或者antden处理触发，也可能来之与调度算法。 执行器需要完成stop的插件，把自己启动的任务给停止掉 Copyright 2020 - 2020. all right reserved，powered by Gitbook该文件修订时间： 2020-07-26 22:33:59 "},"quick_start/schedulingAlgorithm.html":{"url":"quick_start/schedulingAlgorithm.html","title":"调度算法","keywords":"","body":"调度算法 替换方式 调度算法放在目录 /opt/AntDen/scheduler/temple 下，每一个算法是一个可以执行的脚本或者二进制 通过模拟器给算法打分 运行命令 /opt/AntDen/simulator/tools/analyse clotho (其中clotho为你自己的算法名称) 跑出来最终的数值越小算法越好 更换算法的方式 启动调取器时添加环境变量 AntDenSchedulerTemple=pandora:clotho(其中clotho为你自己的算法名称) 在antden中，什么是一个调度算法 antden给调取算法做了统一的数据持久化，调度算法不需要考虑数据怎么保存的问题，如果服务被重启，antden会以标准输入的 方式重新把当前的状态输入给调度算法。 调度算法是一个纯在内存中运行的程序，机器资源信息，作业信息，信息的变更等都会通过标准输入提供给调度算法， 调度算法通过标准输出把要调度起来运行的task信息输出。 算法的编写方式 调度算法包括一下几个函数 setMachine( %m ) ip1: hostname: 10-60-79-144 group: foo envhard: arch=x86_64,os=Linux envsoft: SELinux=Disabled switchable: 1 workable: 1 role: slave,ingress,master mon: health=1,load=0.1 ip2: hostname: 10-60-79-144 envhard: arch=x86_64,os=Linux envsoft: SELinux=Disabled switchable: 1 group: foo workable: 1 role: slave,ingress,master mon: health=1,load=0.1 告知调度算法机器的信息 setMachineAttr( ip, k, v ) 修改某个机器的某个属性， 如机器ip1如果掉线， 会调用这个函数的 setMachineAttr( 'ip1', 'mon', 'health=0' ) setJobAttr( jobid, k, v ) 同理修改的是作业的属性 setResource( %r ) ip1: - [ CPU, 0, 2048 ] - [ GPU, 0, 1 ] - [ GPU, 1, 1 ] - [ MEM, 0, 1839 ] - [ PORT, 65000, 1 ] - [ PORT, 65001, 1 ] 机器的资源信息 loadTask( @task ) - jobid: J01 taskid: T01 status: stoped hostip: 127.0.0.1 executer: ~ resources: - [ CPU, 0, 2048 ] - [ GPU, 0, 1 ] - jobid: J01 taskid: T02 status: stoped hostip: 127.0.0.1 executer: ~ resources: - [ CPU, 0, 2048 ] - [ GPU, 0, 1 ] 如果调度器被重启，antden通过这个函数告知调度算法之前已经调取起来当前还没结束的任务 submitJob( conf ) conf: - executer: name: exec param: exec: echo success scheduler: count: 10 envhard: arch=x86_64,os=Linux envsoft: app1=1.0 ip: 127.0.0.1 # resources: [ GPU, 0, 2 ] - executer: name: exec param: exec: echo success scheduler: count: 10 envhard: arch=x86_64,os=Linux envsoft: app1=1.0 resources: [ GPU, 0, 2 ] group: foo nice: 5 domain: abc.com jobid: J.20200206.114247.252746.499 owner: root name: job.abc 给调度算法提交作业 stop(jobid) 让调度算法要停止该作业 stoped(@task) taskid: T01 jobid: J01 status: success result: exit:0 msg: mesg1 usetime: 3 - taskid: T02 jobid: J01 status: success result: exit:0 msg: mesg1 usetime: 3 告知调度算法，这些任务已经退出，并提供了任务的一些退出信息。 调度算法可以根据这个信息来判断任务是否异常，调度算法可以选择重新在产生一个任务 apply() antden会定时去调用调度算法的这个函数（默认1秒钟调用一次），看是否有task产生。 这个是调度算法的输出。在调用这个函数的时候，调度算法如果找到了可以运行人任务，把它输出到标准输出 time() 告知当前时间，模拟器运行时是一个快速执行的过程，在调用time的时候调度算法需要返回一个时间，或者是经过了几个周期 模拟器会结合这个数值来评判一个调度算法的好坏 调度算法的输入输出的样子 在执行模拟器任务后，在/opt/AntDen/scheduler/temple/run 下 可以看到类似 20200726_224304.9648.in 20200726_224304.9648.out的文件 其中in后缀的是提供给调取算法的标准输入， out后缀的是调度算法print在标准输出的信息。 如果这两个文件里面的格式是正确的，这个调度算法可以替换到antden中使用（但效果如果需要看具体的实现） 输入 {\"name\":\"time\",\"data\":[1]} {\"name\":\"apply\",\"data\":[]} {\"name\":\"setMachine\",\"data\":[\"10.0.1.1\",{\"hostname\":\"node.1.1\",\"switchable\":1,\"role\":\"slave\",\"workable\":1,\"group\":\"foo\",\"envhard\":\"arch=x86_64,os=Linux\",\"envsoft\":\"SELinux=Disabled\",\"mon\":\"MEM=1159,health=1,load=0.26\"}]} {\"data\":[\"10.0.1.1\",[[\"CPU\",0,\"1\"],[\"MEM\",0,\"1\"],[\"GPU\",\"0\",\"1\"],[\"GPU\",\"1\",\"1\"],[\"GPU\",\"2\",\"1\"],[\"GPU\",\"3\",\"1\"]]],\"name\":\"setResource\"} {\"name\":\"setMachine\",\"data\":[\"10.0.1.2\",{\"hostname\":\"node.1.2\",\"switchable\":1,\"workable\":1,\"role\":\"slave\",\"group\":\"foo\",\"envhard\":\"arch=x86_64,os=Linux\",\"envsoft\":\"SELinux=Disabled\",\"mon\":\"MEM=1159,health=1,load=0.26\"}]} {\"data\":[\"10.0.1.2\",[[\"CPU\",0,\"1\"],[\"MEM\",0,\"1\"],[\"GPU\",\"0\",\"1\"],[\"GPU\",\"1\",\"1\"],[\"GPU\",\"2\",\"1\"],[\"GPU\",\"3\",\"1\"]]],\"name\":\"setResource\"} {\"name\":\"setMachine\",\"data\":[\"10.0.1.3\",{\"mon\":\"MEM=1159,health=1,load=0.26\",\"envsoft\":\"SELinux=Disabled\",\"envhard\":\"arch=x86_64,os=Linux\",\"group\":\"foo\",\"workable\":1,\"role\":\"slave\",\"switchable\":1,\"hostname\":\"node.1.3\"}]} {\"name\":\"setResource\",\"data\":[\"10.0.1.3\",[[\"CPU\",0,\"1\"],[\"MEM\",0,\"1\"],[\"GPU\",\"0\",\"1\"],[\"GPU\",\"1\",\"1\"],[\"GPU\",\"2\",\"1\"],[\"GPU\",\"3\",\"1\"]]]} {\"data\":[{\"jobid\":\"J.1\",\"group\":\"foo\",\"nice\":\"5\",\"conf\":[{\"executer\":{\"name\":\"exec\",\"param\":{\"runtime\":\"3600\",\"exec\":\"sleep 300\"}},\"scheduler\":{\"count\":\"1\",\"resources\":[[\"CPU\",\".\",\"1\"]],\"envhard\":\"arch=x86_64,os=Linux\",\"envsoft\":\"app1=1.0\"}}]}],\"name\":\"submitJob\"} {\"name\":\"addProduct\",\"data\":[{\"res\":[[\"CPU\",\".\",\"1\"],[\"MEM\",\".\",\"1\"],[\"GPU\",\".\",\"4\"]],\"conf\":{\"group\":\"foo\",\"name\":\"vm1\",\"id\":\"0001\",\"startingtime\":\"300\",\"cost\":\"100\",\"shutdowntime\":\"20\",\"unit\":\"3600\"}}]} {\"name\":\"time\",\"data\":[2]} {\"name\":\"apply\",\"data\":[]} {\"name\":\"setMachine\",\"data\":[\"10.0.2.1\",{\"envhard\":\"arch=x86_64,os=Linux\",\"role\":\"master\",\"workable\":1,\"group\":\"foo\",\"hostname\":\"node.2.1\",\"switchable\":1,\"mon\":\"MEM=1159,health=1,load=0.26\",\"envsoft\":\"SELinux=Disabled\"}]} {\"name\":\"setResource\",\"data\":[\"10.0.2.1\",[[\"CPU\",0,\"1\"],[\"MEM\",0,\"1\"],[\"GPU\",\"0\",\"1\"],[\"GPU\",\"1\",\"1\"],[\"GPU\",\"2\",\"1\"],[\"GPU\",\"3\",\"1\"]]]} {\"name\":\"submitJob\",\"data\":[{\"nice\":\"5\",\"conf\":[{\"scheduler\":{\"count\":\"1\",\"resources\":[[\"CPU\",\".\",\"1\"],[\"MEM\",\".\",\"1\"],[\"GPU\",\".\",\"1\"]],\"envsoft\":\"app1=1.0\",\"envhard\":\"arch=x86_64,os=Linux\"},\"executer\":{\"param\":{\"runtime\":\"3600\",\"exec\":\"sleep 300\"},\"name\":\"exec\"}}],\"jobid\":\"J.2\",\"group\":\"foo\"}]} {\"name\":\"time\",\"data\":[3]} {\"name\":\"apply\",\"data\":[]} {\"name\":\"submitJob\",\"data\":[{\"jobid\":\"J.3\",\"group\":\"foo\",\"nice\":\"5\",\"conf\":[{\"executer\":{\"name\":\"exec\",\"param\":{\"exec\":\"sleep 300\",\"runtime\":\"3600\"}},\"scheduler\":{\"count\":\"1\",\"envsoft\":\"app1=1.0\",\"envhard\":\"arch=x86_64,os=Linux\",\"resources\":[[\"CPU\",\".\",\"1\"],[\"MEM\",\".\",\"1\"],[\"GPU\",\".\",\"1\"]]}}]}]} {\"name\":\"time\",\"data\":[4]} {\"data\":[],\"name\":\"apply\"} {\"data\":[{\"group\":\"foo\",\"jobid\":\"J.4\",\"conf\":[{\"executer\":{\"param\":{\"exec\":\"sleep 300\",\"runtime\":\"3600\"},\"name\":\"exec\"},\"scheduler\":{\"envhard\":\"arch=x86_64,os=Linux\",\"envsoft\":\"app1=1.0\",\"resources\":[[\"CPU\",\".\",\"1\"],[\"MEM\",\".\",\"1\"],[\"GPU\",\".\",\"1\"]],\"count\":\"1\"}}],\"nice\":\"5\"}],\"name\":\"submitJob\"} {\"name\":\"time\",\"data\":[5]} {\"name\":\"apply\",\"data\":[]} {\"name\":\"submitJob\",\"data\":[{\"group\":\"foo\",\"jobid\":\"J.5\",\"conf\":[{\"scheduler\":{\"count\":\"1\",\"resources\":[[\"CPU\",\".\",\"1\"],[\"MEM\",\".\",\"1\"],[\"GPU\",\".\",\"1\"]],\"envhard\":\"arch=x86_64,os=Linux\",\"envsoft\":\"app1=1.0\"},\"executer\":{\"name\":\"exec\",\"param\":{\"exec\":\"sleep 300\",\"runtime\":\"3600\"}}}],\"nice\":\"5\"}]} {\"name\":\"time\",\"data\":[6]} {\"name\":\"apply\",\"data\":[]} {\"data\":[{\"nice\":\"5\",\"conf\":[{\"scheduler\":{\"resources\":[[\"CPU\",\".\",\"1\"],[\"MEM\",\".\",\"1\"],[\"GPU\",\".\",\"1\"]],\"envhard\":\"arch=x86_64,os=Linux\",\"envsoft\":\"app1=1.0\",\"count\":\"1\"},\"executer\":{\"name\":\"exec\",\"param\":{\"runtime\":\"3600\",\"exec\":\"sleep 300\"}}}],\"jobid\":\"J.6\",\"group\":\"foo\"}],\"name\":\"submitJob\"} {\"data\":[7],\"name\":\"time\"} {\"name\":\"apply\",\"data\":[]} {\"data\":[{\"nice\":\"5\",\"conf\":[{\"executer\":{\"name\":\"exec\",\"param\":{\"runtime\":\"3600\",\"exec\":\"sleep 300\"}},\"scheduler\":{\"envsoft\":\"app1=1.0\",\"envhard\":\"arch=x86_64,os=Linux\",\"resources\":[[\"CPU\",\".\",\"1\"],[\"MEM\",\".\",\"1\"],[\"GPU\",\".\",\"1\"]],\"count\":\"1\"}}],\"jobid\":\"J.7\",\"group\":\"foo\"}],\"name\":\"submitJob\"} {\"data\":[8],\"name\":\"time\"} {\"data\":[],\"name\":\"apply\"} {\"name\":\"submitJob\",\"data\":[{\"nice\":\"5\",\"conf\":[{\"scheduler\":{\"count\":\"1\",\"envhard\":\"arch=x86_64,os=Linux\",\"envsoft\":\"app1=1.0\",\"resources\":[[\"CPU\",\".\",\"1\"],[\"MEM\",\".\",\"1\"],[\"GPU\",\".\",\"1\"]]},\"executer\":{\"param\":{\"exec\":\"sleep 300\",\"runtime\":\"3600\"},\"name\":\"exec\"}}],\"jobid\":\"J.8\",\"group\":\"foo\"}]} {\"name\":\"time\",\"data\":[9]} {\"name\":\"apply\",\"data\":[]} {\"name\":\"submitJob\",\"data\":[{\"nice\":\"5\",\"conf\":[{\"executer\":{\"name\":\"exec\",\"param\":{\"runtime\":\"3600\",\"exec\":\"sleep 300\"}},\"scheduler\":{\"resources\":[[\"CPU\",\".\",\"1\"],[\"MEM\",\".\",\"1\"],[\"GPU\",\".\",\"1\"]],\"envhard\":\"arch=x86_64,os=Linux\",\"envsoft\":\"app1=1.0\",\"count\":\"1\"}}],\"jobid\":\"J.9\",\"group\":\"foo\"}]} {\"data\":[10],\"name\":\"time\"} {\"name\":\"apply\",\"data\":[]} {\"name\":\"submitJob\",\"data\":[{\"conf\":[{\"scheduler\":{\"resources\":[[\"CPU\",\".\",\"1\"],[\"MEM\",\".\",\"1\"],[\"GPU\",\".\",\"1\"]],\"envsoft\":\"app1=1.0\",\"envhard\":\"arch=x86_64,os=Linux\",\"count\":\"1\"},\"executer\":{\"param\":{\"runtime\":\"3600\",\"exec\":\"sleep 300\"},\"name\":\"exec\"}}],\"nice\":\"5\",\"group\":\"foo\",\"jobid\":\"J.10\"}]} 输出 [{\"jobid\":\"J.1\",\"ingress\":null,\"taskid\":\"T.1.001\",\"group\":\"foo\",\"hostip\":\"10.0.1.3\",\"executer\":{\"name\":\"exec\",\"param\":{\"exec\":\"sleep 300\",\"runtime\":\"3600\"}},\"resources\":[[\"CPU\",\"0\",\"1\"]]}] {\"name\":\"time\",\"data\":[3]} [{\"executer\":{\"param\":{\"exec\":\"sleep 300\",\"runtime\":\"3600\"},\"name\":\"exec\"},\"resources\":[[\"CPU\",\"0\",\"1\"],[\"MEM\",\"0\",\"1\"],[\"GPU\",\"3\",\"1\"]],\"jobid\":\"J.2\",\"ingress\":null,\"group\":\"foo\",\"taskid\":\"T.2.001\",\"hostip\":\"10.0.1.1\"}] {\"name\":\"time\",\"data\":[4]} [{\"ingress\":null,\"jobid\":\"J.3\",\"hostip\":\"10.0.1.2\",\"taskid\":\"T.3.001\",\"group\":\"foo\",\"executer\":{\"name\":\"exec\",\"param\":{\"runtime\":\"3600\",\"exec\":\"sleep 300\"}},\"resources\":[[\"CPU\",\"0\",\"1\"],[\"MEM\",\"0\",\"1\"],[\"GPU\",\"2\",\"1\"]]}] {\"name\":\"time\",\"data\":[5]} Copyright 2020 - 2020. all right reserved，powered by Gitbook该文件修订时间： 2020-07-26 23:17:56 "},"quick_start/datasets.html":{"url":"quick_start/datasets.html","title":"数据集类型","keywords":"","body":"数据集 可以看到，托管一个数据集需要5个字段。 Name 数据集的名称 Info 数据集的信息，比如rsyncd的地址 Type 数据集的类型（当前默认存在两个数据类型，rsyncd和data-o，类型可以自定义，但是需要提供相应的插件对接） Group数据集所在的组，（机器资源组名和数据集组名相同的时候，机器有权限使用该数据集） Token数据集使用的token信息 插件 /opt/mydan/dan/antden/code/datasets 目录下是数据集管理插件存放位置， 目录下可以看到有目录 rsyncd， 在rsyncd目录下有两个可执行文件client和slave 如果需要添加其他数据集合的管理，需要添加对应的插件到该目录中 具体插件怎么编写，在后续章节中展开 Copyright 2020 - 2020. all right reserved，powered by Gitbook该文件修订时间： 2020-07-26 23:37:18 "}}